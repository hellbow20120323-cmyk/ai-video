'use client'

import React, { useState, useEffect, useMemo } from 'react'
import { useAssetStore } from '@/store/useAssetStore'
import { useProjectStore } from '@/store/useProjectStore'
import { AssetCategory } from '@/types/assets'
import { Button } from '@/app/components'
import { Scene, Script } from '@/types/script'
import { 
  Home as HomeIcon,
  Folder,
  X,
  Image,
  Edit3,
  RefreshCw,
  Volume2,
  CheckCircle,
  Clock,
  Loader,
  Sparkles as SparklesIcon,
  User
} from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'

// 分镜类型
type StoryboardStatus = 'image-generated' | 'audio-synthesized' | 'waiting-render' | 'pending'

type StoryboardItem = {
  id: string
  imageUrl?: string
  characterIds: string[]
  sceneId: string | null
  dialogue: string
  visualDescription?: string
  status: StoryboardStatus
  isGeneratingAudio: boolean
  projectId: string | null
  scriptId?: string | null // 关联的剧本 ID，用于幂等性判断
}

// 注意：场景数据现在从 props 中的 storeScenes 获取，不再使用硬编码的 mockScenes

// 音色预设
const voicePresets = [
  { id: 'gentle-female', name: '温柔女声' },
  { id: 'deep-male', name: '低沉男声' },
  { id: 'sweet', name: '甜美' },
  { id: 'mechanical', name: '机械' },
]

interface StoryboardManagementProps {
  currentProjectId: string | null
  storeCharacters: any[] // 通过 useMemo 处理过的角色列表
  storeProps: any[] // 通过 useMemo 处理过的道具列表
  storeScenes: any[] // 通过 useMemo 处理过的场景列表
  selectedScript: Script | null // 当前选中的剧本
  scripts?: Script[] // 当前项目的所有剧本列表（用于自动关联）
  onNavigateToOverview: () => void
  onNavigateToAssets?: () => void // 导航到资产中心的回调
  onSelectScript?: (script: Script | null) => void // 选择剧本的回调（用于自动关联）
}

// 角色多选组件
function CharacterMultiSelect({
  storyboardId,
  selectedIds,
  onSelectionChange,
  storeCharacters,
  autoGeneratedAssetIds
}: {
  storyboardId: string
  selectedIds: string[]
  onSelectionChange: (ids: string[]) => void
  storeCharacters: any[]
  autoGeneratedAssetIds: Set<string>
}) {
  const [isOpen, setIsOpen] = useState(false)
  const dropdownRef = React.useRef<HTMLDivElement>(null)

  React.useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside)
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [isOpen])

  const toggleCharacter = (characterId: string) => {
    if (selectedIds.includes(characterId)) {
      onSelectionChange(selectedIds.filter(id => id !== characterId))
    } else {
      onSelectionChange([...selectedIds, characterId])
    }
  }

  const removeCharacter = (characterId: string) => {
    onSelectionChange(selectedIds.filter(id => id !== characterId))
  }

  const getCharacterAvatar = (characterId: string): string | null => {
    // 检查点：确保角色 ID 能在 storeCharacters 中找到
    const character = storeCharacters.find(c => c.id === characterId)
    if (!character) {
      console.warn(`[CharacterMultiSelect] 角色 ID ${characterId} 在 storeCharacters 中未找到`)
      return null
    }
    const store = useAssetStore.getState()
    const assets = store.getAssetsByCategory(AssetCategory.CHARACTER)
    const asset = assets.find(a => a.name === character.name)
    return asset?.referenceImageUrl || null
  }
  
  const getAssetImageUrl = (asset: { referenceImageUrl?: string | null; category: AssetCategory }): string | null => {
    if (asset.referenceImageUrl) {
      return asset.referenceImageUrl
    }
    return null
  }

  return (
    <div className="relative" ref={dropdownRef}>
      {/* 下拉按钮 */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full px-3 py-2 bg-slate-800/50 border border-white/10 rounded-lg text-white text-sm flex items-center justify-between hover:border-cyan-500/50 transition-all"
      >
        <span className="text-gray-400">选择角色</span>
        <span className="text-xs text-gray-500">{selectedIds.length} 已选</span>
      </button>

      {/* 下拉菜单 */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.2 }}
            className="absolute z-50 w-full mt-1 bg-slate-800 border border-white/10 rounded-lg shadow-xl max-h-60 overflow-y-auto"
          >
            {storeCharacters.length === 0 ? (
              <div className="px-3 py-2 text-sm text-gray-400 text-center">暂无角色</div>
            ) : (
              storeCharacters.map(character => {
                const isSelected = selectedIds.includes(character.id)
                const isAutoGenerated = autoGeneratedAssetIds.has(character.id)
                const avatarUrl = getCharacterAvatar(character.id)
                
                return (
                  <button
                    key={character.id}
                    onClick={() => toggleCharacter(character.id)}
                    className={`w-full px-3 py-2 text-left text-sm flex items-center gap-2 hover:bg-slate-700/50 transition-all ${
                      isSelected ? 'bg-cyan-500/20' : ''
                    }`}
                  >
                    {avatarUrl ? (
                      <img src={avatarUrl} alt={character.name} className="w-6 h-6 rounded-full object-cover" />
                    ) : (
                      <div className="w-6 h-6 rounded-full bg-cyan-500/20 flex items-center justify-center text-xs text-cyan-400">
                        {character.name.charAt(0)}
                      </div>
                    )}
                    <span className="flex-1 text-white">{character.name}</span>
                    {isSelected && (
                      <CheckCircle size={14} className="text-cyan-400" />
                    )}
                    {isAutoGenerated && (
                      <div className="w-2 h-2 bg-blue-400 rounded-full" title="自动生成" />
                    )}
                  </button>
                )
              })
            )}
          </motion.div>
        )}
      </AnimatePresence>

      {/* 已选角色标签 */}
      {selectedIds.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-2">
          <AnimatePresence mode="popLayout">
            {selectedIds.map(charId => {
              const character = storeCharacters.find(c => c.id === charId)
              if (!character) return null
              const avatarUrl = getCharacterAvatar(charId)
              
              return (
                <motion.div
                  key={charId}
                  layout
                  initial={{ opacity: 0, scale: 0.8 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.8 }}
                  className="flex items-center gap-2 px-2 py-1 bg-gray-100 rounded-full text-sm"
                >
                  {avatarUrl ? (
                    <img src={avatarUrl} alt={character.name} className="w-5 h-5 rounded-full object-cover" />
                  ) : (
                    <div className="w-5 h-5 rounded-full bg-cyan-500/20 flex items-center justify-center text-xs text-cyan-600">
                      {character.name.charAt(0)}
                    </div>
                  )}
                  <span className="text-gray-700">{character.name}</span>
                  <button
                    onClick={() => removeCharacter(charId)}
                    className="ml-1 text-gray-500 hover:text-gray-700 transition-colors"
                  >
                    <X size={14} />
                  </button>
                </motion.div>
              )
            })}
          </AnimatePresence>
        </div>
      )}
    </div>
  )
}

export default function StoryboardManagement({
  currentProjectId,
  storeCharacters,
  storeProps,
  storeScenes,
  selectedScript,
  scripts = [], // 当前项目的所有剧本列表
  onNavigateToOverview,
  onNavigateToAssets, // 导航到资产中心的回调
  onSelectScript // 选择剧本的回调
}: StoryboardManagementProps) {
  // 防止水合冲突：添加 mounted 状态
  const [mounted, setMounted] = useState(false)
  
  useEffect(() => {
    setMounted(true)
  }, [])
  
  // 直接使用 props，它们已经在父组件中用 useMemo 处理过了
  // 不需要再次 memoize，避免不必要的依赖
  
  // 稳定 autoGeneratedAssetIds 引用
  const autoGeneratedAssetIdsFromStore = useAssetStore((state) => (state as any).autoGeneratedAssetIds)
  const autoGeneratedAssetIds = useMemo(() => {
    return autoGeneratedAssetIdsFromStore || new Set<string>()
  }, [autoGeneratedAssetIdsFromStore])

  // 资产隔离：创建角色 ID 到 voiceId 的映射表（使用 useMemo 防止死循环）
  // 确保分镜在加载时，能通过角色 ID 实时找回对应的语音设定
  const characterVoiceMap = useMemo(() => {
    const map = new Map<string, string>()
    storeCharacters.forEach(char => {
      // 使用角色的 voiceId，如果没有则使用默认值 'shimmer'
      const voiceId = (char as any).voiceId || 'shimmer'
      map.set(char.id, voiceId)
    })
    
    // 调试日志：输出映射表信息
    if (mounted && storeCharacters.length > 0) {
      console.log(`[StoryboardManagement] 角色语音映射表已创建: ${map.size} 个角色`)
      console.log(`  - 当前项目 ID: ${currentProjectId}`)
      console.log(`  - storeCharacters 数量: ${storeCharacters.length}`)
      storeCharacters.forEach(char => {
        const voiceId = map.get(char.id) || 'shimmer'
        console.log(`  - 角色 "${char.name}" (ID: ${char.id}) → 音色: ${voiceId}`)
      })
    }
    
    return map
  }, [storeCharacters, mounted, currentProjectId])
  
  // 分镜管理相关状态 - 移到组件内部
  // 初始化函数，避免每次渲染都创建新数组
  const getInitialStoryboards = (projectId: string | null): StoryboardItem[] => [
    {
      id: 'sb-1',
      characterIds: [],
      sceneId: null,
      dialogue: '这里是第一段对白，点击可编辑...',
      status: 'pending',
      isGeneratingAudio: false,
      projectId: projectId
    },
    {
      id: 'sb-2',
      characterIds: [],
      sceneId: null,
      dialogue: '这里是第二段对白，点击可编辑...',
      status: 'pending',
      isGeneratingAudio: false,
      projectId: projectId
    },
    {
      id: 'sb-3',
      characterIds: [],
      sceneId: null,
      dialogue: '这里是第三段对白，点击可编辑...',
      status: 'pending',
      isGeneratingAudio: false,
      projectId: projectId
    },
    {
      id: 'sb-4',
      characterIds: [],
      sceneId: null,
      dialogue: '这里是第四段对白，点击可编辑...',
      status: 'pending',
      isGeneratingAudio: false,
      projectId: projectId
    },
    {
      id: 'sb-5',
      characterIds: [],
      sceneId: null,
      dialogue: '这里是第五段对白，点击可编辑...',
      status: 'pending',
      isGeneratingAudio: false,
      projectId: projectId
    },
    {
      id: 'sb-6',
      characterIds: [],
      sceneId: null,
      dialogue: '这里是第六段对白，点击可编辑...',
      status: 'pending',
      isGeneratingAudio: false,
      projectId: projectId
    },
  ]
  
  // 使用空数组作为初始状态，避免在初始化时依赖 currentProjectId
  const [allStoryboards, setAllStoryboards] = useState<StoryboardItem[]>([])
  const [editingStoryboardId, setEditingStoryboardId] = useState<string | null>(null)
  const [editingDialogue, setEditingDialogue] = useState('')
  const [isInitialized, setIsInitialized] = useState(false)
  
  // 全局风格设定（从 localStorage 加载）
  const [globalStyle, setGlobalStyle] = useState<string>(() => {
    if (typeof window === 'undefined') return ''
    try {
      return localStorage.getItem('storyboard_global_style') || ''
    } catch {
      return ''
    }
  })

  // 保存全局风格到 localStorage
  useEffect(() => {
    if (typeof window === 'undefined') return
    try {
      if (globalStyle.trim()) {
        localStorage.setItem('storyboard_global_style', globalStyle)
      } else {
        localStorage.removeItem('storyboard_global_style')
      }
    } catch {
      // 静默处理错误
    }
  }, [globalStyle])

  // 保存分镜数据到 localStorage（供外部读取）
  // 使用防抖，避免频繁写入
  // 防止水合冲突：确保在 mounted 后才保存数据
  useEffect(() => {
    if (!mounted || typeof window === 'undefined') return
    
    const timer = setTimeout(() => {
      try {
        // 读取现有的所有分镜数据
        const existing = localStorage.getItem('ai-video-platform-storyboards')
        let allProjectsStoryboards: StoryboardItem[] = []
        
        if (existing) {
          try {
            allProjectsStoryboards = JSON.parse(existing)
          } catch {
            // 如果解析失败，使用空数组
            console.error('[StoryboardManagement] 解析现有分镜数据失败')
          }
        }
        
        // 移除当前项目的旧数据，然后添加新数据
        // 强化数据写入：确保过滤时检查 projectId 存在
        const filtered = allProjectsStoryboards.filter(
          (sb: StoryboardItem) => sb.projectId && sb.projectId !== currentProjectId
        )
        const updated = [...filtered, ...allStoryboards]
        
        localStorage.setItem('ai-video-platform-storyboards', JSON.stringify(updated))
        console.log(`[StoryboardManagement] 保存项目 ${currentProjectId} 的分镜: ${allStoryboards.length} 个`)
      } catch (error) {
        console.error('[StoryboardManagement] 保存分镜数据失败:', error)
      }
    }, 300) // 300ms 防抖
    
    return () => clearTimeout(timer)
  }, [mounted, allStoryboards, currentProjectId])
  
  // 初始化：当项目切换时，从 localStorage 加载分镜列表
  // 防止水合冲突：确保在 mounted 后才加载数据
  useEffect(() => {
    if (!mounted || typeof window === 'undefined') return
    
    if (!currentProjectId) {
      setAllStoryboards([])
      setIsInitialized(false)
      return
    }
    
    // 如果已经初始化过当前项目，不再重复加载
    if (isInitialized) return
    
    // 从 localStorage 加载当前项目的分镜
    try {
      const stored = localStorage.getItem('ai-video-platform-storyboards')
      if (stored) {
        const parsed: StoryboardItem[] = JSON.parse(stored)
        // 强化数据读取：确保过滤时检查 projectId 存在
        const projectStoryboards = parsed.filter(sb => sb.projectId === currentProjectId)
        
        console.log(`[StoryboardManagement] 加载项目 ${currentProjectId} 的分镜: ${projectStoryboards.length} 个`)
        
        // 检查点：验证分镜中的角色 ID 是否能在 storeCharacters 中找到
        if (projectStoryboards.length > 0) {
          projectStoryboards.forEach(sb => {
            const missingCharacterIds = sb.characterIds.filter(id => 
              !storeCharacters.some(c => c.id === id)
            )
            if (missingCharacterIds.length > 0) {
              console.warn(`[StoryboardManagement] 分镜 ${sb.id} 有 ${missingCharacterIds.length} 个角色 ID 在 storeCharacters 中未找到:`, missingCharacterIds)
              console.warn(`  - 分镜的 projectId: ${sb.projectId}`)
              console.warn(`  - 当前项目的 projectId: ${currentProjectId}`)
              console.warn(`  - storeCharacters 数量: ${storeCharacters.length}`)
              console.warn(`  - 可能原因：资产过滤逻辑（projectId）与分镜过滤逻辑不一致`)
            }
          })
          
          setAllStoryboards(projectStoryboards)
        } else {
          // 如果没有数据，使用空数组（不再使用初始值，等待 selectedScript 触发生成）
          setAllStoryboards([])
        }
      } else {
        // 如果没有存储，使用空数组
        setAllStoryboards([])
      }
    } catch (error) {
      console.error('[StoryboardManagement] 加载分镜数据失败:', error)
      // 静默处理错误，使用空数组
      setAllStoryboards([])
    }
    setIsInitialized(true)
  }, [mounted, currentProjectId, isInitialized])

  // 增强提示词函数：将剧本描述封装成更适合 AI 绘图的提示词
  const enhancePrompt = (visualDesc: string): string => {
    if (!visualDesc || visualDesc.trim() === '') {
      return ''
    }
    
    // 在原始描述后添加 AI 绘图增强词
    const enhancements = [
      'cinematic lighting',
      'highly detailed',
      '8k',
      'shot on 35mm lens',
      'professional photography',
      'cinematic composition',
    ]
    
    // 组合增强后的提示词
    return `${visualDesc.trim()}, ${enhancements.join(', ')}`
  }

  // 根据角色名称匹配角色 ID 的辅助函数
  const matchCharacterIdsByName = useMemo(() => {
    return (characterNames: string[]): string[] => {
      if (!characterNames || characterNames.length === 0) return []
      
      const matchedIds: string[] = []
      characterNames.forEach(name => {
        // 精确匹配
        const exactMatch = storeCharacters.find(char => char.name === name)
        if (exactMatch) {
          matchedIds.push(exactMatch.id)
        } else {
          // 模糊匹配（忽略大小写和空格）
          const fuzzyMatch = storeCharacters.find(char => 
            char.name.toLowerCase().trim() === name.toLowerCase().trim()
          )
          if (fuzzyMatch) {
            matchedIds.push(fuzzyMatch.id)
          } else {
            // 包含匹配（更宽松）
            const looseMatch = storeCharacters.find(char => 
              char.name.toLowerCase().includes(name.toLowerCase()) ||
              name.toLowerCase().includes(char.name.toLowerCase())
            )
            if (looseMatch) {
              matchedIds.push(looseMatch.id)
            }
          }
        }
      })
      
      // 去重
      return Array.from(new Set(matchedIds))
    }
  }, [storeCharacters])

  // 监听 selectedScript：当剧本变化时，自动生成分镜卡片
  // 防止水合冲突：确保在 mounted 后才执行
  useEffect(() => {
    if (!mounted) return
    
    // 如果没有选中剧本或没有项目 ID，不执行
    if (!selectedScript || !currentProjectId) return

    // 如果剧本没有场景，不创建分镜
    if (!selectedScript.scenes || selectedScript.scenes.length === 0) {
      return
    }

    // 使用函数式更新，在更新时检查幂等性
    setAllStoryboards(prev => {
      // 检查该剧本是否已经有对应的分镜（幂等性判断）
      // 强化数据读取：确保检查时验证 projectId 和 scriptId 都存在
      const existingStoryboardsForScript = prev.filter(
        sb => sb.scriptId === selectedScript.id && 
              sb.projectId === currentProjectId &&
              sb.projectId !== null &&
              sb.scriptId !== null
      )

      // 如果已经存在该剧本的分镜，不重复创建
      if (existingStoryboardsForScript.length > 0) {
        console.log(`[StoryboardManagement] 剧本 "${selectedScript.title}" 的分镜已存在，跳过生成`)
        return prev
      }

      try {
        // 将剧本的场景转换为分镜卡片
        const newStoryboards: StoryboardItem[] = selectedScript.scenes.map((scene: Scene, index: number) => {
          // 根据场景中的角色名称匹配角色 ID
          const characterIds = scene.characters && scene.characters.length > 0
            ? matchCharacterIdsByName(scene.characters)
            : []
          
          // 强化数据写入：确保每个分镜对象都必须包含 projectId 和 scriptId
          return {
            id: `sb-${selectedScript.id}-${index}-${Date.now()}`,
            characterIds: characterIds,
            sceneId: null,
            dialogue: scene.dialogue || '',
            visualDescription: scene.content || '',  // 视觉画面描述
            status: 'pending' as StoryboardStatus,
            isGeneratingAudio: false,
            projectId: currentProjectId, // 强化：必须包含 projectId
            scriptId: selectedScript.id, // 强化：必须包含 scriptId，用于幂等性判断和数据关联
          }
        })

        console.log(`[StoryboardManagement] 为剧本 "${selectedScript.title}" 生成 ${newStoryboards.length} 个分镜`)
        
        // 追加新生成的分镜到现有列表（不覆盖已有分镜）
        return [...prev, ...newStoryboards]
      } catch (error) {
        console.error('根据剧本生成分镜失败:', error)
        // 静默处理错误，返回原列表
        return prev
      }
    })
  }, [mounted, selectedScript?.id, currentProjectId, matchCharacterIdsByName]) // 添加 mounted 依赖

  // 优化数据读取：使用 useMemo 包装过滤逻辑，确保数据在模块切换间保持稳定
  // 这样即便没有选中具体剧本，也能看到当前项目下的所有分镜
  const displayStoryboards = useMemo(() => {
    if (!mounted || !currentProjectId) return []
    return allStoryboards.filter(s => s.projectId === currentProjectId)
  }, [allStoryboards, currentProjectId, mounted])
  
  // 自动关联：如果当前 selectedScript 为空但项目中有剧本，自动将列表中的第一个剧本设为 selectedScript
  useEffect(() => {
    if (!mounted || !currentProjectId) return
    if (selectedScript) return // 如果已经有选中的剧本，不执行自动关联
    
    // 过滤当前项目的剧本
    const projectScripts = scripts.filter(s => s.projectId === currentProjectId)
    
    if (projectScripts.length > 0 && onSelectScript) {
      // 自动选择第一个剧本
      console.log('[StoryboardManagement] 自动关联第一个剧本:', projectScripts[0].title)
      onSelectScript(projectScripts[0])
    }
  }, [mounted, currentProjectId, scripts, selectedScript, onSelectScript])

  if (!currentProjectId) {
    return (
      <div className="flex-1 flex items-center justify-center bg-gradient-to-br from-gray-50 to-white">
        <div className="text-center max-w-md">
          <div className="w-24 h-24 bg-gradient-to-br from-cyan-100 to-blue-100 rounded-3xl flex items-center justify-center mx-auto mb-6 shadow-lg">
            <Folder size={48} className="text-cyan-600" />
          </div>
          <h3 
            className="text-2xl font-semibold text-gray-800 mb-3"
            style={{ fontFamily: '-apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", sans-serif' }}
          >
            请先选择项目
          </h3>
          <p className="text-gray-600 mb-8 text-lg">
            在管理分镜之前，请先在项目中心选择一个项目
          </p>
          <Button
            onClick={onNavigateToOverview}
            variant="primary"
            size="lg"
            icon={HomeIcon}
          >
            前往项目中心
          </Button>
        </div>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-full bg-gradient-to-br from-gray-900 via-slate-800 to-gray-900 p-6 overflow-y-auto">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-white mb-2">分镜管理</h1>
        <p className="text-gray-400">管理视频分镜，关联角色和场景，生成对白音频</p>
      </div>

      {/* 全局风格设定 */}
      <div className="mb-6 bg-slate-800/50 backdrop-blur-xl border border-white/10 rounded-xl p-4">
        <div className="flex items-center gap-4">
          <div className="flex-1">
            <label className="block text-sm font-medium text-gray-300 mb-2 flex items-center gap-2">
              <SparklesIcon size={16} className="text-cyan-400" />
              全局风格设定
            </label>
            <input
              type="text"
              value={globalStyle}
              onChange={(e) => setGlobalStyle(e.target.value)}
              placeholder="例如：赛博朋克风格、新海诚动画风、3D 粘土风格..."
              className="w-full px-4 py-2.5 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-cyan-500/50 focus:ring-2 focus:ring-cyan-500/20 text-sm"
            />
            <p className="text-xs text-gray-500 mt-2">
              此风格将自动应用到所有分镜图的生成中
            </p>
          </div>
          {globalStyle && (
            <button
              onClick={() => setGlobalStyle('')}
              className="px-4 py-2.5 text-gray-400 hover:text-white hover:bg-slate-700/50 rounded-lg transition-all text-sm"
            >
              <X size={18} />
            </button>
          )}
        </div>
      </div>

      {/* 防止水合冲突：确保分镜列表的渲染完全包裹在 mounted 状态判断中 */}
      {!mounted ? (
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <Loader size={32} className="animate-spin text-gray-400 mx-auto mb-4" />
            <p className="text-gray-500">加载分镜数据...</p>
          </div>
        </div>
      ) : (
        <>
          {/* 六宫格布局 */}
          <div className="grid grid-cols-2 md:grid-cols-3 gap-6">
            {displayStoryboards.map((storyboard) => {
          // 资产隔离：根据分镜的 characterIds 查找角色（稳定引用，防止死循环）
          // 检查点：确保 storyboard.characterIds 里的 ID 能在 storeCharacters 中找到对应的角色
          const selectedCharacters = storyboard.characterIds
            .map(id => {
              const character = storeCharacters.find(c => c.id === id)
              if (!character) {
                // 调试日志：如果找不到角色，输出警告
                console.warn(`[StoryboardManagement] 分镜 ${storyboard.id} 的角色 ID ${id} 在 storeCharacters 中未找到`)
                console.warn(`  - 分镜的 projectId: ${storyboard.projectId}`)
                console.warn(`  - 当前项目的 projectId: ${currentProjectId}`)
                console.warn(`  - storeCharacters 数量: ${storeCharacters.length}`)
                console.warn(`  - storeCharacters 的 projectId 列表:`, storeCharacters.map(c => ({ id: c.id, name: c.name, projectId: c.projectId })))
                console.warn(`  - 可能原因：资产过滤逻辑（projectId）与分镜过滤逻辑不一致`)
              }
              return character
            })
            .filter((c): c is NonNullable<typeof c> => c !== undefined)
          
          // 验证：如果匹配的角色数量少于 characterIds，说明有角色丢失
          if (selectedCharacters.length < storyboard.characterIds.length && mounted) {
            const missingIds = storyboard.characterIds.filter(id => !selectedCharacters.some(c => c.id === id))
            console.warn(`[StoryboardManagement] 分镜 ${storyboard.id} 有 ${missingIds.length} 个角色 ID 未找到:`, missingIds)
            console.warn(`  - 分镜的 projectId: ${storyboard.projectId}`)
            console.warn(`  - 当前项目的 projectId: ${currentProjectId}`)
            console.warn(`  - 可能原因：资产过滤逻辑（projectId）与分镜过滤逻辑不一致`)
          }
          
          // 从 storeScenes 中查找选中的场景（而不是 mockScenes）
          const selectedScene = storyboard.sceneId
            ? storeScenes.find(s => s.id === storyboard.sceneId)
            : null
          
          // 资产隔离：根据第一个角色的 voiceId 获取音色名称
          // 使用 characterVoiceMap（已用 useMemo 包装）确保稳定性
          // 检查点：确保能通过角色 ID 实时找回对应的语音设定
          const getVoiceName = (characterIds: string[]): string => {
            if (characterIds.length === 0) {
              return '默认女声'
            }
            
            const firstCharacterId = characterIds[0]
            
            // 验证：确保角色 ID 在 storeCharacters 中存在
            const character = storeCharacters.find(c => c.id === firstCharacterId)
            if (!character) {
              console.warn(`[StoryboardManagement] 获取音色名称时，角色 ID ${firstCharacterId} 未找到`)
              return '默认女声'
            }
            
            // 从映射表中获取 voiceId
            const voiceId = characterVoiceMap.get(firstCharacterId) || 'shimmer'
            
            // 映射 OpenAI 音色 ID 到中文名称
            const voiceNameMap: Record<string, string> = {
              'alloy': 'Alloy（中性）',
              'echo': 'Echo（回声）',
              'fable': 'Fable（寓言）',
              'onyx': 'Onyx（深沉男声）',
              'nova': 'Nova（年轻女声）',
              'shimmer': 'Shimmer（温暖女声）',
            }
            
            return voiceNameMap[voiceId] || '默认女声'
          }
          
          const currentVoiceName = getVoiceName(storyboard.characterIds)

          return (
            <div
              key={storyboard.id}
              className="bg-slate-900/50 backdrop-blur-xl border border-white/10 rounded-xl overflow-hidden shadow-xl"
            >
              {/* 预览图区域 */}
              <div className="relative aspect-video bg-gradient-to-br from-cyan-900/30 to-purple-900/30 group">
                {storyboard.imageUrl ? (
                  <img 
                    src={storyboard.imageUrl} 
                    alt="分镜预览" 
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <Image size={48} className="text-gray-500" />
                  </div>
                )}
                
                {/* 重绘悬浮按钮 */}
                <button
                  onClick={() => {
                    setAllStoryboards(prev => 
                      prev.map(sb => 
                        sb.id === storyboard.id 
                          ? { ...sb, status: 'image-generated' as StoryboardStatus }
                          : sb
                      )
                    )
                  }}
                  className="absolute top-2 right-2 p-2 bg-black/60 backdrop-blur-sm rounded-lg text-white hover:bg-black/80 transition-all opacity-0 group-hover:opacity-100"
                >
                  <RefreshCw size={16} />
                </button>

                {/* 生成分镜按钮 */}
                {!storyboard.imageUrl && storyboard.dialogue && storyboard.characterIds.length > 0 && storyboard.sceneId && (
                  <button
                    onClick={() => {
                      // 检查点：确保角色 ID 能在 storeCharacters 中找到
                      const characters = storyboard.characterIds
                        .map(id => {
                          const character = storeCharacters.find(c => c.id === id)
                          if (!character) {
                            console.warn(`[StoryboardManagement] 生成分镜时，角色 ID ${id} 未找到`)
                          }
                          return character
                        })
                        .filter((c): c is NonNullable<typeof c> => c !== undefined)
                      
                      // 从 storeScenes 中查找场景（而不是 mockScenes）
                      const scene = storeScenes.find(s => s.id === storyboard.sceneId)
                      
                      if (characters.length === 0 || !scene) {
                        if (characters.length === 0) {
                          console.warn(`[StoryboardManagement] 生成分镜失败：分镜 ${storyboard.id} 的角色 ID 在 storeCharacters 中未找到`)
                          console.warn(`  - 分镜的 characterIds:`, storyboard.characterIds)
                          console.warn(`  - 分镜的 projectId: ${storyboard.projectId}`)
                          console.warn(`  - 当前项目的 projectId: ${currentProjectId}`)
                          console.warn(`  - storeCharacters 数量: ${storeCharacters.length}`)
                        }
                        return
                      }

                      const visualDesc = storyboard.visualDescription || ''
                      const enhancedVisualDesc = enhancePrompt(visualDesc)
                      const characterDescriptions = characters.map(c => c.description).join(', ')
                      // 使用场景的 description 字段作为 prompt（Scene 接口中有 description 字段）
                      const scenePrompt = scene.description || scene.name
                      let combinedPrompt = `${enhancedVisualDesc} ${storyboard.dialogue ? `. ${storyboard.dialogue}` : ''}. Characters: ${characterDescriptions}. Scene: ${scenePrompt}. 16:9 aspect ratio`.trim()
                      if (globalStyle && globalStyle.trim()) {
                        combinedPrompt = `${combinedPrompt}, ${globalStyle.trim()}`
                      }

                      setAllStoryboards(prev => 
                        prev.map(sb => 
                          sb.id === storyboard.id 
                            ? { ...sb, status: 'waiting-render' as StoryboardStatus }
                            : sb
                        )
                      )

                      setTimeout(() => {
                        setAllStoryboards(prev => 
                          prev.map(sb => 
                            sb.id === storyboard.id 
                              ? { 
                                  ...sb, 
                                  imageUrl: `https://via.placeholder.com/1920x1080/1a1a2e/ffffff?text=分镜+${storyboard.id}`,
                                  status: 'image-generated' as StoryboardStatus
                                }
                              : sb
                          )
                        )
                      }, 3000)
                    }}
                    className="absolute bottom-2 left-2 px-4 py-2 bg-cyan-500/90 hover:bg-cyan-600 text-white rounded-lg text-sm font-medium transition-all backdrop-blur-sm"
                  >
                    生成分镜
                  </button>
                )}
              </div>

              {/* 卡片内容区域 */}
              <div className="p-4 space-y-4">
                {/* 关联槽位 */}
                <div className="space-y-2">
                  <label className="text-xs font-medium text-gray-400">角色（可多选）</label>
                  <CharacterMultiSelect
                    key={`character-select-${storyboard.id}`}
                    storyboardId={storyboard.id}
                    selectedIds={storyboard.characterIds}
                    onSelectionChange={(ids) => {
                      setAllStoryboards(prev => 
                        prev.map(sb => 
                          sb.id === storyboard.id 
                            ? { ...sb, characterIds: ids }
                            : sb
                        )
                      )
                    }}
                    storeCharacters={storeCharacters}
                    autoGeneratedAssetIds={autoGeneratedAssetIds}
                  />
                </div>

                <div className="space-y-2">
                  <label className="text-xs font-medium text-gray-400">场景</label>
                  <select
                    value={storyboard.sceneId || ''}
                    onChange={(e) => {
                      setAllStoryboards(prev => 
                        prev.map(sb => 
                          sb.id === storyboard.id 
                            ? { ...sb, sceneId: e.target.value || null }
                            : sb
                        )
                      )
                    }}
                    className="w-full px-3 py-2 bg-slate-800/50 border border-white/10 rounded-lg text-white text-sm focus:outline-none focus:border-cyan-500/50"
                  >
                    <option value="">选择场景</option>
                    {storeScenes.length === 0 ? (
                      <option value="" disabled className="bg-slate-800 text-gray-500">
                        暂无场景，请先在资产中心添加场景
                      </option>
                    ) : (
                      storeScenes.map(scene => (
                        <option key={scene.id} value={scene.id} className="bg-slate-800">
                          {scene.name}
                        </option>
                      ))
                    )}
                  </select>
                </div>

                {/* 视觉描述（Prompt） */}
                {storyboard.visualDescription && (
                  <div className="space-y-2">
                    <label className="text-xs font-medium text-gray-400 flex items-center gap-2">
                      <Image size={14} />
                      视觉描述 (Prompt)
                    </label>
                    <div className="px-3 py-2 bg-slate-800/30 border border-cyan-500/30 rounded-lg text-white text-xs">
                      {storyboard.visualDescription}
                    </div>
                  </div>
                )}

                {/* 文本/对白区 */}
                <div className="space-y-2">
                  <label className="text-xs font-medium text-gray-400">对白</label>
                  {editingStoryboardId === storyboard.id ? (
                    <div className="space-y-2">
                      <textarea
                        value={editingDialogue}
                        onChange={(e) => setEditingDialogue(e.target.value)}
                        onBlur={() => {
                          setAllStoryboards(prev => 
                            prev.map(sb => 
                              sb.id === storyboard.id 
                                ? { ...sb, dialogue: editingDialogue }
                                : sb
                            )
                          )
                          setEditingStoryboardId(null)
                        }}
                        className="w-full px-3 py-2 bg-slate-800/50 border border-cyan-500/50 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500/20 resize-none"
                        rows={3}
                        autoFocus
                      />
                      <button
                        onClick={() => {
                          setAllStoryboards(prev => 
                            prev.map(sb => 
                              sb.id === storyboard.id 
                                ? { ...sb, dialogue: editingDialogue }
                                : sb
                            )
                          )
                          setEditingStoryboardId(null)
                        }}
                        className="w-full px-3 py-1.5 bg-cyan-500 hover:bg-cyan-600 text-white rounded-lg text-sm font-medium transition-all"
                      >
                        保存
                      </button>
                    </div>
                  ) : (
                    <div
                      onClick={() => {
                        setEditingStoryboardId(storyboard.id)
                        setEditingDialogue(storyboard.dialogue)
                      }}
                      className="px-3 py-2 bg-slate-800/50 border border-white/10 rounded-lg text-white text-sm min-h-[60px] cursor-text hover:border-cyan-500/50 transition-all flex items-start gap-2"
                    >
                      <Edit3 size={14} className="text-gray-500 mt-0.5 flex-shrink-0" />
                      <span className="flex-1">{storyboard.dialogue}</span>
                    </div>
                  )}
                </div>

                {/* 语音合成状态指示器 */}
                {storyboard.characterIds.length > 0 && (
                  <div className="space-y-2">
                    {(() => {
                      // 检查第一个角色是否有 voiceId
                      const firstCharacterId = storyboard.characterIds[0]
                      const character = storeCharacters.find(c => c.id === firstCharacterId)
                      const hasVoiceId = character && (character as any).voiceId
                      
                      if (!hasVoiceId && character) {
                        // 如果没有设置 voiceId，显示提醒
                        return (
                          <div className="px-3 py-2 bg-amber-500/20 border border-amber-500/50 rounded-lg flex items-center gap-2 text-xs text-amber-300">
                            <Volume2 size={14} className="flex-shrink-0" />
                            <span className="flex-1">角色 "{character.name}" 未设置语音音色</span>
                            {onNavigateToAssets && (
                              <button
                                onClick={(e) => {
                                  e.stopPropagation()
                                  onNavigateToAssets()
                                }}
                                className="px-2 py-1 bg-amber-500/30 hover:bg-amber-500/50 rounded text-xs font-medium transition-all"
                              >
                                前往设置
                              </button>
                            )}
                          </div>
                        )
                      }
                      
                      // 如果已设置 voiceId，显示状态
                      if (hasVoiceId) {
                        const voiceId = (character as any).voiceId
                        const voiceNameMap: Record<string, string> = {
                          'alloy': 'Alloy（中性）',
                          'echo': 'Echo（回声）',
                          'fable': 'Fable（寓言）',
                          'onyx': 'Onyx（深沉男声）',
                          'nova': 'Nova（年轻女声）',
                          'shimmer': 'Shimmer（温暖女声）',
                        }
                        const voiceName = voiceNameMap[voiceId] || voiceId
                        
                        return (
                          <div className="px-3 py-2 bg-green-500/20 border border-green-500/50 rounded-lg flex items-center gap-2 text-xs text-green-300">
                            <Volume2 size={14} className="flex-shrink-0" />
                            <span className="flex-1">语音音色: {voiceName}</span>
                            <CheckCircle size={14} className="flex-shrink-0" />
                          </div>
                        )
                      }
                      
                      return null
                    })()}
                  </div>
                )}

                {/* 合成语音按钮 */}
                <button
                  onClick={async () => {
                    if (storyboard.characterIds.length === 0) {
                      alert('请先选择角色')
                      return
                    }

                    if (!storyboard.dialogue || storyboard.dialogue.trim().length === 0) {
                      alert('请先输入对白内容')
                      return
                    }

                    setAllStoryboards(prev => 
                      prev.map(sb => 
                        sb.id === storyboard.id 
                          ? { ...sb, isGeneratingAudio: true }
                          : sb
                      )
                    )

                    try {
                      // 资产隔离：根据分镜绑定的 characterIds 自动匹配角色的专属 voiceId
                      // 优先使用第一个角色的 voiceId，如果多个角色则使用第一个
                      // 检查点：确保角色 ID 能在 storeCharacters 中找到，并能获取对应的 voiceId
                      const firstCharacterId = storyboard.characterIds[0]
                      
                      // 验证：确保角色存在
                      const character = storeCharacters.find(c => c.id === firstCharacterId)
                      if (!character) {
                        console.error(`[StoryboardManagement] 合成语音时，角色 ID ${firstCharacterId} 未找到`)
                        console.error(`  - 分镜 ID: ${storyboard.id}`)
                        console.error(`  - 分镜的 projectId: ${storyboard.projectId}`)
                        console.error(`  - 当前项目的 projectId: ${currentProjectId}`)
                        console.error(`  - storeCharacters 数量: ${storeCharacters.length}`)
                        throw new Error(`角色 ID ${firstCharacterId} 未找到，无法合成语音`)
                      }
                      
                      // 从映射表中获取 voiceId
                      const voiceId = characterVoiceMap.get(firstCharacterId) || 'shimmer' // 默认使用 shimmer
                      
                      console.log(`[StoryboardManagement] 为角色 "${character.name}" (ID: ${firstCharacterId}) 使用音色: ${voiceId}`)

                      // 调用 TTS API
                      const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                          text: storyboard.dialogue,
                          voiceId: voiceId,
                          model: 'tts-1',
                        }),
                      })

                      if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}))
                        throw new Error(errorData.error || 'TTS 生成失败')
                      }

                      // 获取音频流并播放
                      const audioBlob = await response.blob()
                      const audioUrl = URL.createObjectURL(audioBlob)
                      const audio = new Audio(audioUrl)
                      
                      audio.onended = () => {
                        URL.revokeObjectURL(audioUrl)
                      }
                      
                      audio.onerror = () => {
                        URL.revokeObjectURL(audioUrl)
                        throw new Error('音频播放失败')
                      }
                      
                      await audio.play()

                      // 更新状态为已合成
                      setAllStoryboards(prev => 
                        prev.map(sb => 
                          sb.id === storyboard.id 
                            ? { 
                                ...sb, 
                                isGeneratingAudio: false,
                                status: 'audio-synthesized' as StoryboardStatus
                              }
                            : sb
                        )
                      )
                    } catch (error: any) {
                      console.error('TTS 生成失败:', error)
                      setAllStoryboards(prev => 
                        prev.map(sb => 
                          sb.id === storyboard.id 
                            ? { ...sb, isGeneratingAudio: false }
                            : sb
                        )
                      )
                      alert(error.message || 'TTS 生成失败，请检查 API 配置')
                    }
                  }}
                  disabled={storyboard.isGeneratingAudio || storyboard.characterIds.length === 0}
                  className="w-full flex flex-col items-center gap-2 px-4 py-2.5 bg-purple-500/80 hover:bg-purple-600/80 text-white rounded-lg text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {storyboard.isGeneratingAudio ? (
                    <>
                      <div className="flex items-end gap-1 h-4">
                        <div className="w-1 bg-white rounded-full wave-bar" style={{ animationDelay: '0ms', height: '40%' }}></div>
                        <div className="w-1 bg-white rounded-full wave-bar" style={{ animationDelay: '100ms', height: '70%' }}></div>
                        <div className="w-1 bg-white rounded-full wave-bar" style={{ animationDelay: '200ms', height: '100%' }}></div>
                        <div className="w-1 bg-white rounded-full wave-bar" style={{ animationDelay: '300ms', height: '85%' }}></div>
                        <div className="w-1 bg-white rounded-full wave-bar" style={{ animationDelay: '400ms', height: '60%' }}></div>
                      </div>
                      <span className="text-xs text-center">
                        正在以 <span className="font-semibold">[{currentVoiceName || '未知'}]</span> 模式合成
                      </span>
                    </>
                  ) : (
                    <>
                      <div className="flex items-center gap-2">
                        <Volume2 size={16} />
                        <span>合成语音</span>
                      </div>
                      {currentVoiceName && (
                        <span className="text-xs opacity-75">
                          将使用: {currentVoiceName}
                        </span>
                      )}
                    </>
                  )}
                </button>

                {/* 生成状态显示 */}
                <div className="flex items-center gap-2 text-xs">
                  {storyboard.status === 'image-generated' && (
                    <>
                      <CheckCircle size={14} className="text-green-400" />
                      <span className="text-green-400">图片已生成</span>
                    </>
                  )}
                  {storyboard.status === 'audio-synthesized' && (
                    <>
                      <CheckCircle size={14} className="text-blue-400" />
                      <span className="text-blue-400">音频已合成</span>
                    </>
                  )}
                  {storyboard.status === 'waiting-render' && (
                    <>
                      <Clock size={14} className="text-yellow-400" />
                      <span className="text-yellow-400">等待渲染</span>
                    </>
                  )}
                  {storyboard.status === 'pending' && (
                    <>
                      <Loader size={14} className="text-gray-400 animate-spin" />
                      <span className="text-gray-400">待处理</span>
                    </>
                  )}
                </div>
              </div>
            </div>
          )
        })}
          </div>
        </>
      )}
    </div>
  )
}
